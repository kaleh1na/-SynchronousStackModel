| Лабораторная работа №2 | M3102 | АОВС |
| ---------------------- | ----------- | ---- |
| Построение логических схем   | Алехина Ксения Степановна       | 2024 |


## Инструментарий

Icarus Verilog 12

## Вариант

- logisim normal
- structural verilog normal
- behaviour verilog normal


## Результат работы на тестовых данных: [https://github.com/skkv-itmo-comp-arch/se-comp-arch24-circuit-kaleh1na/actions/runs/8435029850]()

# Описание

## Logisim

### Краткое описание

 Стек был реализован с помощью пяти ячеек памяти на 4 бита, каждая из них в свою очередь использует 4 D-триггера для хранения каждого из битов, может читать и записывать четырехбитные числа.

 Также хранится отдельная ячейка на 3 бита(соответственно использует 3 D-триггера) - это указатель на верхушку стека(номер ячейки стека, являющейся верхушкой). Его изменение(инкремент, декремент) производится по аналогии с JK-триггером - мы храним 2 ячейки - текущее и предыдущее состояние указателя.
 
 Инкремент и декремент в свою очередь реализованы с помощью сумматоров, также реализовано и обращение по индексу при get(берется сумма индекса с текущим указателем). При всех этих операциях конечный результат берется по модулю 5(так как мы имеем 5 ячеек стека). 
 
 Стек заполняется "снизу вверх" - сначала ячейка под номером 4, после под номером 3 и т.д. Это было сделано для удобства обращения по индексу при get. 

### Описание вспомогательных модулей

Теперь рассмотрим работу каждого модуля поподробнее, для каждого построим таблицу истинности и, если схема была составлена с помощью ДНФ, соответствующую карту Карно. Начнем со вспомогательных модулей.

#### Модули, связанные со сложением

- **HalfSummator**
  * Входы: A0, A1 - 2 однобитных числа
  * Выходы: S, C - сумма входных и чисел и  переполнение(нужен ли переход на следующий разряд)
  
  | A0 | A1 | S | C |
  |-|-|-|-|
  | 0 | 0 | 0 | 0 |
  | 0 | 1 | 1 | 0 |
  | 1 | 0 | 1 | 0 |
  | 1 | 1 | 0 | 1 |
  
  Построение данного модуля тривиально - сумма берется как xor входных значений, переполнение - как их and.

- **Summator**
  * Входы: A0, A1, A2 - 2 однобитных числа, а также переполнение с предыдущего разряда
  * Выходы: S, C - сумма в этом разряде и новое переполнение

  | A0 | A1 | A2 | S | C |
  |-|-|-|-|-|
  | 0 | 0 | 0 | 0 | 0 |
  | 0 | 0 | 1 | 1 | 0 |
  | 0 | 1 | 0 | 1 | 0 |
  | 0 | 1 | 1 | 0 | 1 |
  | 1 | 0 | 0 | 1 | 0 |
  | 1 | 0 | 1 | 0 | 1 |
  | 1 | 1 | 0 | 0 | 1 |
  | 1 | 1 | 1 | 1 | 1 |

  Данный модуль сделан с помощью ранее реализованного полусумматора - для начала сложим полусумматором A1 и A2, получим S1 и С1, после сложим полусумматором A0 и получившуюся в предыдущей операции S1, получим S2 и C2. S2 и будет нужным выходом для S, а вот С возьмем xor-ом получившихся в первом и втором случае С1 и С2.
  > На самом деле, не важно, возьмем мы их xor-oм или or-ом, так как нам важно только знать случилось ли переволнение хотя бы один раз, а 2 раза оно случиться не может: если в первом полусумматоре переполнение, то S1 = 0, а значит, во втором полусумматоре переполнения произойти не может(оно происходит только при двух входных единицах)

- **Mod5**
  * Входы: A0, A1, A2, A2 - 4 бита соответствующего четырехбитного числа
  * Выходы: Q - трехбитное число - модуль пятерки входного числа. 

   Заметим, что в ходе исполнения всей программы модуль пятерки будет применяться максимум для числа 11, так как модуль пятерки мы используем только в сумме двух трехбитных чисел, где либо складываем указатель, который принимает значения от 0 до 4 с единицей или с четверкой, либо с индексом при get. Индекс при get максимум равен 7, указатель максимум равен 4, в сумме максимум получается 11. Получается, мы можем четко определить таблицу истинности для первых 12 комбинаций, а для остальных четырех подобрать удобные значения для упрощения схемы.

  | A0 | A1 | A2 | A3 | Q |
  |-|-|-|-|-|
  | 0 | 0 | 0 | 0 | 000 | 
  | 0 | 0 | 0 | 1 | 001 | 
  | 0 | 0 | 1 | 0 | 010 |
  | 0 | 0 | 1 | 1 | 011 | 
  | 0 | 1 | 0 | 0 | 100 | 
  | 0 | 1 | 0 | 1 | 000 |  
  | 0 | 1 | 1 | 0 | 001 | 
  | 0 | 1 | 1 | 1 | 010 | 
  | 1 | 0 | 0 | 0 | 011 | 
  | 1 | 0 | 0 | 1 | 100 | 
  | 1 | 0 | 1 | 0 | 000 |
  | 1 | 0 | 1 | 1 | 001 | 
  | 1 | 1 | 0 | 0 | xxx | 
  | 1 | 1 | 0 | 1 | xxx | 
  | 1 | 1 | 1 | 0 | xxx | 
  | 1 | 1 | 1 | 1 | xxx | 

   Для каждого из битов построим ДНФ с помощью карты Карно. 
  | A0 A1 \ A2 A3 | 00 | 01 | 11 | 10 |
   |-|-|-|-|-|
   | **00** | 0 | 0 | 0 | 0 |
   | **01** | 1 | 0 | 0 | 0 |
   | **11** | 1(x) | 1(x) | x | x |
   | **10** | 0 | 1 | 0 | 0 |

   Для удобства в ячейки 1100 и 1101 поставим единицы - тогда будет меньше литералов в компонентах ДНФ. Итак, получается (A1 and notA2 and notA3) or (A0 and notA2 and A3). 

   | A0 A1 \ A2 A3 | 00 | 01 | 11 | 10 |
   |-|-|-|-|-|
   | **00** | 0 | 0 | 1 | 1 |
   | **01** | 0 | 0 | 1 | 0 |
   | **11** | 1(x) | x | x | x |
   | **10** | 1 | 0 | 0 | 0 |

   Для удобства в ячейку 1100 поставим единицу. Итак, получается (A0 and notA2 and notA3) or (notA0 and A2 and A3) or (notA0 and notA1 and A2)

   | A0 A1 \ A2 A3 | 00 | 01 | 11 | 10 |
   |-|-|-|-|-|
   | **00** | 0 | 1 | 1 | 0 |
   | **01** | 0 | 0 | 0 | 1 |
   | **11** | 1(x) | x | x | 1(x) |
   | **10** | 1 | 0 | 1 | 0 |

   Для удобства в ячейки 1100, 1110 поставим единицы. Итак, получается (A0 and notA2 and notA3) or (notA1 and notA2 and A3) or (A1 and A2 and notA3) or (notA1 and A2 and A3)

   С помощью получившихся ДНФ легко построить логические схемы, так как по сути, все что мы используем, это and or и not. Таким образом, сделаем это для каждого бита, а после соединим их в трехбитный выход с помощью разветвителя.

- **Sum3**
   * Входы: A0, A1 - два трехбитных числа
   * Выходы: Q - их сумма, взятая по модулю пять.
  
  Таблица истинности для данного модуля тривиальна(используются тривиальные математические операции)
  Работа данного модуля осуществляется с помощью последовательного поразрядного применения сумматоров. Сначала применяем полусумматор для последнего разряда, после для остальных разрядов применяем сумматоры с учетом переполнения предыдущего разряда. Все суммы запоминаем и таким образом после всех действий получаем четырехбитное число: нулевой бит - переполнение в последнем сумматоре, остальные биты - соответственные им получившиеся суммы. Сразу же берем получившееся число по модулю 5 с помощью вышеописанного модуля. Получившееся после взятия по модулю число - наш ответ.

- **Increment**
   * Входы: IND, need - текущий указатель и флаг, нужно ли нам делать инкремент 
   * Выходы: newIND - получившийся указатель после инкремента(если он был нужен)
  
  Если нам нужно сделать инкремент, мы просто с помощью модуля Sum3 прибавляем к указателю число 4 (100). Если же инкремент делать не нужно, прибавляем 0 (000) и текущий указатель не меняется.

  Заметим, что в указателе может лежать только число от 0 (000) по 4 (100), поэтому таблицу истинности для остальных входных данных рассматривать не будем.

  |IND|need|Q|
  |-|-|-|
  |000|0|000|
  |001|0|001|
  |010|0|010|
  |011|0|011|
  |100|0|100|
  |000|1|100|
  |001|1|000|
  |010|1|001|
  |011|1|010|
  |100|1|011|

  Данный модуль применяется при команде push - мы должны сдвинуть указатель на 1 ячейку вверх(так как заполняем стек снизу вверх) циклически. Это соответствует -1 по модулю 5, а значит +4 по модулю 5.
  
- **Decrement**
   * Входы: IND, need - текущий указатель и флаг, нужно ли нам делать декремент 
   * Выходы: newIND - получившийся указатель после декремента(если он был нужен)
  
Если нам нужно сделать декремент, мы просто с помощью модуля Sum3 прибавляем к указателю число 1 (001). Если же декремент делать не нужно, прибавляем 0 (000) и текущий указатель не меняется.

  |IND|need|Q|
  |-|-|-|
  |000|0|000|
  |001|0|001|
  |010|0|010|
  |011|0|011|
  |100|0|100|
  |000|1|001|
  |001|1|010|
  |010|1|011|
  |011|1|100|
  |100|1|000|

  Данный модуль применяется при команде pop - мы должны сдвинуть указатель на 1 ячейку вниз(так как заполняем стек снизу вверх) циклически. Это соответствует +1 по модулю 5.

#### Модули, связанные с памятью

- **RStrigger**
  * Входы: R, C, S, reset
   S - установить бит в 1, R - сбросить бит в 0
   С - синхронизация
   reset - нужно ли обнулить внутреннюю память
   > Также в Logisim используется элемент POR(Power-On reset), для того чтобы при запуске программы занулить внутреннюю память
  * Выходы: Q - прочитанный либо записанный бит

 Для начала рассмотрим таблицу истинности обычного RS-триггера(без синхронизации и reset)

  |R|S|Q|
  |-|-|-|
  |0|0|сохранение предыдущего значения|
  |0|1|1|
  |1|0|0|
  |1|1|без разницы(в нашем случае 0)|

Реализуем данную схему при помощь двух nor. На вход первого идет R, на вход второго S. Причем выход каждого из норов идет как вход к другому. Засчет этого у триггера присутствует внутреннее состояние, благодаря которому мы можем запоминать внутри него нужные биты. Тогда при вводе двух нулей ответ будет как раз таки зависеть от этого внутреннего состояния. При вводе же одной единицы будет происходить изменение внутреннего состояния(будет зануляться выход того nor, к которому подключена единица, а так как он занулился, выход другого nor станет единицей)

Теперь добавим синхронизацию, так как никто не гарантирует, что сигналы с проводов придут одновременно. Для этого нужно просто сделать 2 and для R с синхронизацией и для S c синхронизацией. Тогда если синхронизация равна нулю мы не можем менять внутреннее состояние, а только читать.

  Наконец, добавим reset - для этого сделаем or с выходом второго nor, таким образом, на вход первого nor придет единица, и выходное значение занулится. 

- **D-trigger**
   * Входы: С - синхронизация, и в целом флаг, нужно ли нам писать это число, D - бит для записи, если нужно писать, reset - нужно ли обнулить память
   * Выходы: Q - прочитанный бит

По сути, полностью построен на основе RS-триггера. В S отправляем наше значение D, в R - его инвертированное состояние с помощью not. Таким образом, получили ячейку памяти на один бит, из которой можно читать и в которую записывать.
- **StackCell**
  * Входы: RW - R(read), W(write) - единица, если нужно записывать значение, ноль - если нужно читать значение.
  С - синхронизация, reset - описывался ранее, далее не будем расписывать, что он делает, нужно просто провести его из более обширных модулей к вспомогательным и дойти то RS-триггера, чтобы он его обнулил.
  D - четырехбитное значение для записи(если нужно записывать)
  * Выходы: Q - четырехбитное число, прочитанное из ячейки.

По сути, просто разделяем входное четырехбитное значение с помощью разветвителя и каждый отдельный бит храним в отдельном D-триггере. В С каждого D-триггера записываем and изначальной синхронизации и параметра RW, так как C в D-триггерах означает не только синхронизацию, но и то, нужно ли записывать значение, или читать его.

Таким образом, получили ячейку памяти на 4 бита, в которую можно записывать и из которой читать.

- **PointerCell** 
   * Входы: C - синхронизация(но по сути, просто показывает нужно ли записывать или читать значене, с общей синхронизацией из все(CLK) она не связана)
   D - трехбитное значение для записи(если нужно писать), reset
   * Выходы: Q - трехбитное прочитанное значение.

Тут делаем практически все то же самое, что и в StackCell. Разница в том, что здесь мы храним 3 бита, а не 4, так как указатель принимает значения только от 0 до 4 и влазит в 3 бита. Так же нет параметра RW, так как С сразу отвечает за него самостоятельно. 

#### Другие вспомогательные методы

- **Decoder**
  * Входы: A0, A1, A2 - биты соответствующего трехбитного числа, которое нужно распарсить
  * Выходы: Q0, Q1, Q2, Q3, Q4 - показывают, пришло ли число по их индексу. 
  
  По сути, это Decoder3to5. Больше не нужно, так как мы используем его только при парсинге команды(принимает значения от 0 до 3) и при парсинге индекса указателя(принимает значения от 0 до 4).
  Построение тривиально, с помощью and и not, единицей будет всегда только один выход из Q. Если Q3 = 1, значит пришедшее трехбитное число было равно 3(011), и так далее.

  |A0|A1|A2|Q0|Q1|Q2|Q3|Q4|
  |-|-|-|-|-|-|-|-|
  |0|0|0|1|0|0|0|0|
  |0|0|1|0|1|0|0|0|
  |0|1|0|0|0|1|0|0|
  |0|1|1|0|0|0|1|0|
  |1|0|0|0|0|0|0|1|

- **Read**
    * Входы - A - четырехбитное число, R - флаг, нужно ли нам читать это число, или нужно его занулить.
    * Выходы - Q0, Q1, Q2, Q3 - либо прочитанное число, разделенное на биты, либо нули, если не нужно было читать число.
  
При R = 1 просто разветвляет число на биты, при R = 0 возвращает нули. Реализован просто: с помощью разветвителя и and.

### Основные модули

#### Pointer

- Входы: C - синхронизация, reset, needInc, needDec - флаги, показывающие, нужно ли делать инкремент или декремент соответственно.
- Выходы: Q - трехбитное число - прочитанный указатель после инкремента и декремента.

Изменение указателя производится по аналогии с JK-триггером - мы храним 2 ячейки - текущее и предыдущее состояние указателя. При изменении синхронизации с 0 на 1 мы читаем предыдущее состояние, если нужно, изменяем его (есть флаг needInc или needDec и пришла синхронизация) и записываем в текущее. После при изменении синхронизации с 1 на 0 текущее состояние записывается в предыдущее. По сути, это весь принцип работы. Это достигается засчет того, что в первую ячейку стека мы передаем настоящую синхронизацию, а в другую ее инвертированное состояние. (синхронизация для ячейки здесь это не только синхронизация, а еще и показатель нужно ли менять значение внутри ячейки, он будет равен единице если один из флагов needInc и needDec равны единице). На выход мы берем значение сразу же после инкремента и декремента.


#### stack

- Входовыходы: IO_DATA
- Входы: CLK - синхронизация, RESET - обнуление всей внутренней памяти, COMMAND - комманда (00 - nop, 01 - push, 10 - pop, 11 - get), IND - индекс значения относительно верхушки стека которое мы должны прочитать при команде get.

Для начала распарсим команду при помощи Decoder. Далее прочитаем указатель и изменим его если нужно. Нужно делать инкремент, если производится команда push, так как в таком случае мы должны сначала сдвинуть верхушку стека на ячейку вперед, и после записать значение по новому указателю. Декремент нужно делать при команде pop - нужно просто сдвинуть указатель на ячейку назад.

Далее, заметим, что при команде pop нам нужно записать в выход именно удаленное значение, а не то, что лежит в текущий момент по указателю вершины стека. Поэтому в таком случае сразу делаем инкремент(если была команда pop).

После этого складываем получившийся указатель с IND для get, однако, сделать это нужно только если операция get, поэтому в ином случае занулим пришедщший IND.

Итого, мы получили номер ячейки с которой нужно поработать. Парсим это с помощью Decoder, и далее работаем с пятью ячейками памяти. Для каждой из них на вход синхронизация равна единице если единице равна общая синхронизация и мы работаем именно с этой ячейкой, а RW равен единице, если команда push и мы должны записать именну в эту ячейку.

После этого читаем все ячейки с помощью Read, берем or получившихся битов и получаем значения для выхода(после Read мы по сути получили 4 нулевых ячейки и одну истинно равную своему значению).

Входовыход реализован с помощью передаточного вентиля - по сути, комбинации двух транзисторов. Имеет сток, исток, p-затвор и n-затвор. Ожидается, что значения на затворах противоположны. Если на р-затворе значение 0, а на n-затворе 1, то значение с истока передается на сток, иначе остается плавающим.

Мы должны передавать значение на выход только  в случае если пришла синхронизация и выбрана одна из команд pop/get. Отрицание этого и будет идти в p-затвор.

## SystemVerilog structural

Структурное описание схемы выполнено полностью на основе этой же схемы из логисима, объявлен каждый соответственный модуль, каждый провод, вход и выход и т.д, поэтому не будем долго останавливаться на описании модулей.

По сути, весь код состоит из применения и объвления гейтов в подобном формате: модуль название_гейта(выходы, входовыходы, входы), а так же из объявления wire(проводов). 

## SystemVerilog behaviour

Реализован с помощью массива которых хранит 5 4-битных чисел и 3-битного указателя. 

После с помощью тернарного оператора подсоединяем IO_DATA к out - четырехбитный выход, если нужно его присоединить(тут, как и в логисим, выводить нужно при синхронизации равной единице и когда команда либо pop, либо гет).

Все операции обрабатываем с помощью операторов always(буквально значит, что действие выполняется непрерывно). Также используется posedge и negedge - положительный и отрицательный фронт тактовой частоты. По сути posedge A означает: выполняй данный блок действий при A == 1, а negedge A - при A == 0.

При RESET == 1(posedge RESET), всю внутреннюю память обнуляем. 

При CLK == 0(negedge CLK):

Команды ниже выполняем только при RESET == 0, так как RESET выполняется асинхронно.

> Здесь выполняются операции связанные с изменением указателя
- При команде push инкрементируем указатель(делаем +4 и берем по модулю 5. Также не забываем про случай когда указатель был равен 4, тогда, при +4 произойдет переполнение трехбитного числа, поэтому вынесем этот случай в отдельный иф).

- При команде pop записываем в prev_ptr ячейку по текущему указателю для того чтобы вернуть его позже(при CLK == 1), после декрементируем указатель(делаем + 1 и берем по модулю 5).

При CLK == 1(posedge CLK):

Команды ниже выполняем только при RESET == 0, так как RESET выполняется асинхронно.

> Здесь выполняются операции по записи в массив стека/out
- При команде push записываем по указателю IO_DATA.

- При команде pop записываем в out ячейку по индексу prev_ptr(мы запомнили ранее предыдущий указатель, чтобы вернуть теперь удаленную из стека ячейку в output)
- При команде get записываем в out число, взятое по индексу суммы указателя и индекса по модулю пять, взятое все по модулю пять. Не забудем про случай когда указатель = 4 и индекс по модулю 5 равен 4, тут может произойти переполнение трехбитного числа, поэтому вынесем этот случай в отдельный иф.


